
# 코틀린 기초

### 1. 기본 문법
#### 1.1. 주석
주석은 다음과 같이 사용한다.
```kotlin
//   한 줄 짜리 주석
```
```kotlin
/*
    여러 줄 주석
*/
```
```kotlin
/**
   KDoc 여러 줄 주석
*/
```

자바와 달리 코틀린에서는 여러 줄 주석을 여러번 내보시킬 수 있다.
```kotlin
/*
여러줄 주석
/* 주석 안에 내포된 주석 */
*/
println("Hello")
```

---
### 1.2 변수

* **타입 추론**

코틀린에서는 타입을 지정하지 않아도 자동으로 대입하는 값에 따라 타입을 결정한다. 
```kotlin
val immutableInt = 10 //타입 추론 Int
println(immutableInt.javaClass) //타입 추론 Int 형 확인

val immutableString = "string" //타입 추론 String
println(immutableString.javaClass) //타입 추론 String 형 확인
```
```print
출력 결과 : 
int
class java.lang.String
double
```
타입을 명시하고 싶다면 다음과 같이 `:` 이후 해당 타입을 적으면 된다.
```kotlin
val immutableDouble : Double= 10.0 // 타입 명시 Double
println(immutableDouble.javaClass)
```
```print
출력 결과 : double
```
<br>

* **변경 불가능 `val` 불변 변수**

불변 변수를 선언할 때 `val`을 사용하여 변수를 선언한다. 이때 변수는 한번 초기화된 값이 변경이 불가능하기 때문에 아래의 예제와 같이 값을 변경하는 경우에는 컴파일 에러가 발생한다.
```kotlin
val immutableInt = 10 // val 변수 선언 및 초기화
println("immutableInt = ${++immutableInt}") //Val cannot be reassigned : 컴파일 에러
```
<br>

*  **`null` 대입**

`null`이 대입이 가능하기 위해서는 해당 변수의 타입이 `Int?`, `Object?`과 같이 ?이 추가된 타입이어야 하기 때문에 선언시에 ?을 추가해서 변수를 선언해야만 해당 변수에 `null`의 대입이 가능하다.
**`NullPointException`을 방지하기 위해서 설계된 문법**
```kotlin
val notNullInt : Int = null // 에러 발생
val nullInt : Int? = null // null 타입 허용 가능 형식
```
<br>

* **변경 가능 `var` 변수**

변수의 값을 동적으로 변경하기 위해서는 `var`을 사용하여 변수를 선언해야한다.
```kotlin
var mutableInt = 10 // 값 변경 가능 변수
println("mutableInt = ${++mutableInt}") //값 변경 후 출력
```
```print
출력 결과 : mutableInt = 11
```

* **not-null assertion `!!`**

`!!`은 널이 아님을 단언하는 것으로 해당 함수의 결과값이 `null`이 아니라는 것을 명시하는 것이다.  만약 결과가 `null`이 반환된다면 예외를 발생시킨다.
```kotlin
val a = readLine()!!.toInt()
```
<br>

* **예제 통합**
```kotlin
val immutableInt = 10 //타입 추론 Int
val immutableInt2 : Int = 10 //타입 명시
val immutableInt3 : Int? = null //null 타입 허용 가능 형식

var mutableInt = 10 // 값 변경 가능 변수

val a = readLine()!!.toInt() // !! null값을 허용하지 않음을 명시

//오류 x 컴파일 성공 
println(immutableInt.javaClass) //타입 추론 Int 형 확인
println("immutableInt = ${immutableInt}")  
println("immutableInt2 = ${immutableInt2}")  
println("immutableInt3 = ${immutableInt3}")  
println("mutableInt = ${++mutableInt}")  
println("a = ${a}")  
  
//오류 O 컴파일 실패  
println("immutableInt = ${++immutableInt}") //Val cannot be reassigned  
mutableInt = null //Null can not be a value of a non-null type Int  
val toInt = readLine().toInt() //Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
```
---

### 2. 기본 타입

> 자바와 달리 모든 코틀린 타입은 근본적으로 어떤 클래스 정의를 기반으로 만들어진다. 따라서 Int 와 같은 원시 타입도 메서드와 프로퍼티를 제공한다.

####  2.1. 정수 타입   

|이름|크기(byte)|
|--|--:|
|Byte|1|
|Short|2|
|Int|4|
|Long|8|

```kotlin
val n1 = 12345
val n2 = 12_345 // `_`를 이용한 숫자 가독성 향상 표기
val long_n = 30L //Long 형
val bin = 0b1111 //2진법
val hex = 0xff //16진법
val oct = 0111 //8진법 -> [error] : 8진법 지원 x
```
각 정수 타입은 최솟값과 최댓값을 포함하는 상수 정의가 들어있음
```kotlin
Short.MAX_VALUE // -32768
Short.MIN_VALUE // 32767
Int.MAX_VALUE
```

---
####  2.2. 실수 타입

|이름|크기(byte)|
|--|--:|
|Float|4|
|Double|8|
정수 표기 법 예시
```kotlin
val pi = 3.14
val one = 1.0
val quater = .25 // 0.25 0은 생략 가능
```
과학적 표기법 리터럴 사용
```kotlin
val pi = 0.314E1 // 3.14 = 0.314 * 10
val piOver100 = 3.14E-2 = // 0.0314 = 3.14 /100
```
* Float, Double 지원하는 상수

|상수|의미|
|-------------------------|----|
|MIN_VALUE | 각 타입에서 표현할 수 있는 가장 작은 유한값
|MAX_VALUE | 각 타입에서 표현할 수 있는 가장 작은 유한값 
|NEGATIVE_INFINITY| 음의 무한대
|POSITIVE_INFINITY | 양의 무한대
|NaN | 0/0의 결과 처럼 숫자가 아닌 값을 의미

#### 2.3 문자 타입 Char

Char 타입은 유니코드 한 글자를 표현하며 16비트이다. Char 타입의 선언은 다음과 같다.

```kotlin
val alpha = 'z'
val unicode = '한'

println("$unicode type : ${unicode.javaClass}")  
println("$alpha type : ${alpha.javaClass}")
```

문자에 산술 연산을 추가하면 문자를 유니코드 문자 집합 안에서 변경할 수 있다.
```kotlin
var A = 'a'  
var Z = 'z'  
  
A++ 
  
println("A = $A")  
println("distance = ${Z-A} : ${(Z-A).javaClass}");
```

<br>

|특수문자|표기|
|-------|------:|
|탭(tab)|\t|
|백스페이스(backspace)|\b|
|새줄(newline)|\n|
|케리지 리턴|\r|
|작은 따옴표|\\'|
|큰 따옴표|\\"|
|역슬래시|\\\\|
|달러|\\$|

#### 2.4 Boolean 타입
Boolean 연산

* ! : 논리 부정
* or, and, xor : 즉시 계산방식 연산
* ||, && : 지연 계산 방식 연산
<br>

**\+ 즉시 계산 vs 지연 계산**
지연 계산 방식은 왼쪽의 피연산자의 상태에 따라서 오른쪽 피연산자를 계산하지 않는 방식이다. 
```kotlin
val numberString : String? = null  
val sample = numberString != null && numberString!!.toInt() == 1234  
  
print(sample)
```
위의 예제에서 `numberString.toInt()`는 `numberString`이 `null`이라면 예외가 발생할 수 있지만 앞선 `numberString != null`을 통해서 `null`확인을 하고 실행하기 때문에 `NullPointerException`의 발생을 막을 수 있다.

반면에 즉시 계산은 양쪽의 피연산자를 모두 계산하고 논리 계산을 한다는 점이 차이점이다.

#### 2.5 연산자

##### 2.5.1 비트 연산
|연산|뜻|예제|결과|
|--|--|--|--|
|shl|왼쪽 시프트(shift)  |```13 shl 2```|52:0...00110100|
|shr|오른쪽 시프트  |```13 shr 2```|3:0...00000011|
|ushr|부호 없는 오른족 시프트|```13 ushr 2```|3:0...00000011|
|and|비트 곱(AND)  |```13 and 19```|1:0...00000001|
|or  |비트 합(OR)  |```13 or 19```|31:0...00011111|
|xor  |비트 베타합(XOR)  |```13 xor 19```|30: 0...00011110|
|inv  |비트 반전(inversion)  |```13.inv()```|-14: 1...11110010|

##### 2.5.2 비교 연산
|연산자| 상세|
|:---:|:---:|
|A > B	|A가 B보다 크다.|
|A >= B	|A가 B보다 크거나 같다.|
|A < B	|A가 B보다 작다.|
|A <= B	|A가 B보다 작거나 같다.|
|A == B	|A와 B의 값이 같은가?|
|A != B	|A와 B의 값이 다른가?|
|A === B|A 객체와 B 객체가 같은가?|
|A !== B|A 객체와 B 객체가 다른가?|
