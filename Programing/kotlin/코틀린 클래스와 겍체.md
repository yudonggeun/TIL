# 클래스



## 1. 클래스 정의하기

기본적인 클래스 구조

새로 할당된 인스턴스 초기화

가시성 문제

다른 클래스나 함수 본문안에서 선언할 수 있는 특별한 유형의 클래스



기본적으로 클래스 선언은 참조 타입을 정의한다.

인라인 클래스를 사용하면 참조 타입이 아닌 타입을 정의할 수 있다.

### 1.1 클래스 내부 구조



#### 1.1.1 생성자

코틀린에서 생성자는 **기본생성자**와 **보조 생성자**가 있다.



* **보조 생성자**   `constructor`

보조 생성자는 기존의 자바 스타일과 매우 유사한 생성자 방식이다.

```kotlin
class Sample{
    private val var1 : String
    
    constructor(var1 : String){
        this.var1 = var1
    }
}
```

다음 예제 처럼 `constructor` 키워드를 이용하여 생성자를 선언할 수 있다.

```kotlin
class Sample{
    private val var1 : String
    private val var2 : String
    
    constructor(var1 : String){
        this.var1 = var1
        this.var2 = "None"
    }
    
    constructor(var1 : String, var2 : String){
        this.var1 = var1
        this.var2 = var2
    }
}
```

`java`처럼 생성자 역시 다양한 형태로 사용이 가능하다.



* **기본 생성자**  `init`

기본 생성자를 사용하면 코드를 더욱 간결하게 작성이 가능하다. 

앞선 보조 생성자를 이용한 예제를 기본 생성자로 알아보자

```kotlin
class Sample(private val var1: String, private val var2: String = "None")
```

위의 보조 생성자로 생성한 클래스 코드와 동일한 기능을 수행하는 코드이다.  

앞선 예제 코드에 비해서 더욱 간결한 코드인 것이 한눈에 보인다. 하지만 입력받은 파라미터 값 혹은 디폴트 값으로 프로퍼티를 초기화하는 것 말고는 다른 기능을 추가하기에 어렵다. 

따라서 기본 생성자를 사용해서 생성자를 사용할 때 `init`을 사용하여 복잡한 초기화 작업에 대한 코드를 작성할 수 있다.



```kotlin
class Sample(private val var1: String, private val var2: String = "None"){
    init {
        println("init 초기화 작업 실행 1")
    }
    init {
        println("init 초기화 작업 실행 2")
    }
}
```

`init`을 사용하여 생성자 호출시 실행하는 작업을 다음 예제처럼 실행할 수 있다.  

`init`은 여러번 호출 할 수 있다. 여러번 사용한다면 그 호출 순서는 순서대로 호출이 된다.



* **기본 생성자**와 **보조 생성자**을 동시에 사용하기

기본 생성자와 보조 생성자 방법을 혼합해서 사용할 수는 없을까?

```kotlin
class Sample(private val var1: String, private val var2: String = "None"){
    init {
        println("init 초기화 로직 실행")
    }
    
    constructor() : this("var1"){
        println("contructor 초기화 로직 실행")
    }
}
```

```실행 결과
Sample class 생성자 호출 이후 출력 결과 : 
init 초기화 로직 실행
contructor 초기화 로직 실행
```

위의 예제로 만든 `Sample`클래스는 기본 생성자와 보조 생성자를 혼합하여 사용하는 클래스이다. 

기본 생성자와 보조 생성자는 혼합하여 사용이 가능하다. 

이 때 생성자의 호출 순서는 기본 생성자 -> 보조 생성자 순서이다.

또한 보조 생성자를 호출하기 전에 이미 기본 생성자를 사용하여 프로퍼티를 모두 초기화를 해야하기 때문에 불변 타입으로 선언된 프로퍼티의 값을 변경 불가능하다. 이 점을 주의해서 보조 생성자를 사용하자.

보조 생성자는 이름처럼 기본 생성자로 부족한 초기화 과정을 보조하는 생성자의 역할이다. 대부분은 기본 생성자를 이용해서 문제가 해결이 가능하지만 필요한 경우에 보조 생성자를 활용하여 생성자를 사용이 가능하다.



#### 1.1.2 멤버 가시성

가시성을 사용해 구현과 관련한 세부 사항을 캡슐화함으로써 외부 코드로부터 구현 세부 사항을 격리시킬 수 있으므로, 가시성 지정은 클래스 정의 시 아주 중요한 부분이다. 코틀린에서는 클래스 멤버의 가시성을 다음과 같은 변경자 키워드로 지정할 수 있다.

| 변경자 키워드 | 범위      | 설명                                                         |
| ------------- | --------- | ------------------------------------------------------------ |
| public        | 공개      | 멤버를 어디서나 볼 수 있다. 디폴트 가시성으로 사용되기 때문에 명시적으로 표기할 필요는 없다. |
| internal      | 모듈 내부 | 멤버를 멤버가 속한 클래스가 포함된 컴파일 모듈 내부에서만 볼 수 있다. |
| protected     | 보호      | 멤버를 멤버가 속한 클래스와 멤버가 속한 클래스의 모든 하위 클래스 안에서 볼 수 있다. |
| private       | 비공개    | 멤버를 멤버가 속한 클래스 내부에서만 볼 수 있다.             |

```kotlin
class Sample private constructor(private val var1: String, var2: String = "None"){
        
   fun sampleFunction() : String = "sample function"
}
```

함수, 프로퍼티, 생성자에 대해 가시성 변경자를 지원한다. 

주 생성자에 가시성 변경자를 명시할 때는 `constructor`키워드를 같이 명시해야한다는 점을 주의하자.



#### 1.1.3 Inner 클래스와 Nested 클래스

코틀린 클래스는 다른 클래스도 멤버로 가질 수 있다. 

```kotlin
class Outer{
    private val bar = 1
   
    inner class Inner{
        fun foo() = bar //this@Outer.bar
    }
    
    class Nested{
        fun foo() = bar //error 발생
    }
}

fun main() {
    val outer = Outer()
    val inner = outer.Inner()
    val nested = Outer.Nested()
}
```

Inner 클래스와 Nested 클래스의 차이점은 외부 클래스를 참조 할 수 있는가? 이다.

Inner 클래스는 Outer 클래스를 주입하지 않아도 해당 인스턴스에 접근하여 프로퍼티나 함수 등 사용이 가능하다. 반면에 Nested 클래스는 Outer 인스턴스에 접근이 불가능하다.

`main`에서 실행되는 클래스 생성자 호출에서도 차이점이 보인다. Inner 클래스의 인스턴스를 생성할 때는 outer 인스턴스에서 생성자를 호출하여 객체를 생성하지만 Nested 클래스는 Outer.Nested()로 인스턴스에서 호출하지 않는다.



[Inner 클래스 주의점](https://velog.io/@maketheworldwise/%EC%A4%91%EC%B2%A9-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%EC%9C%84%ED%97%98%EC%84%B1)



#### 1.1.4 지역 클래스

```kotlin
class Sample{
    fun function(){
        val functionName = "execute function"

        class Local{
            val name : String = "local class"
            fun printName() = println("$functionName $name")
        }

        val local = Local()

        local.printName()
    }
}
```

코틀린에서는 함수에서 클래스를 정의할 수 있다. 이러한 클래스를 지역 클래스라고 한다.

지역 클래스는 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래슨ㄴ 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획하거나 변경할 수 있다.



## 2. 널 가능성



## 3. 단순한 변수 이상인 프로퍼티



## 4. 객체



## 5. 결론

